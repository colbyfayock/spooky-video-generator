import { promises as fs } from 'fs';
import { v2 as cloudinary } from 'cloudinary';
import pLimit from 'p-limit';
import path from 'path';

cloudinary.config({
  cloud_name: process.env.NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME,
  api_key: process.env.NEXT_PUBLIC_CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

(async function run() {
  // Grab all files from the local filesystem

  const images = await fs.readdir(path.join(process.cwd(), 'images'));

  console.log(`Uploading ${images.length} images...`);

  // Concurrently upload all images max 10 at a time, using automatic captionining
  // and applying the generated caption as metadata to the image asset

  const limit = pLimit(10);

  const imagesToUpload = images.map((image) => {
    return limit(async () => {
      try {
        const extension = path.parse(image).ext;
        const result = await cloudinary.uploader.upload(path.join(process.cwd(), 'images', image), {
          folder: process.env.CLOUDINARY_IMAGES_DIRECTORY,
          public_id: image.replace(extension, ''),
          detection: "captioning",
          on_success: "current_asset.update({ tags: ['autogenerated'], context: { caption: e.upload_info?.info?.detection?.captioning?.data?.caption }})"
        });
        console.log(`Successfully uploaded ${image}`);
        console.log(`> Result: ${result.secure_url}`);
        return result;
      } catch(e) {
        throw new Error(`Failed to upload image: ${(e as Error)?.message || 'Unknown Error'}`);
      }
    })
  });

  await Promise.all(imagesToUpload);
})();